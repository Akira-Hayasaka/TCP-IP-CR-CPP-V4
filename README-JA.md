---
typora-root-url: ./picture
---

1. README の英語版 -> [こちらをクリック](./README-EN.md)

   Dobot TCP-IP-CR-CPP-V4 二次開発 API インターフェース（[TCP-IP-CR-CPP-V4 README](https://github.com/Dobot-Arm/TCP-IP-CR-CPP-V4)）

# 1. 概要

TCP-IP-CR-CPP-V4 は、Dobot 社の TCP/IP プロトコルに基づく C++ ラッパーとして設計されたソフトウェア開発キットです。C++ で開発され、Dobot-TCP-IP 制御通信プロトコルに準拠しています。Socket を通じてロボット端末と TCP 接続を行い、使いやすい API インターフェースを提供します。TCP-IP-CR-CPP-V4 を利用することで、Dobot のロボットへ素早く接続して二次開発を行い、ロボットの制御および利用を実現できます。

## 事前要件

- PC をLANケーブルでコントローラのネットワークポートに接続し、固定 IP を設定してコントローラの IP と同一セグメントにします。無線でコントローラへ接続することも可能です。

  有線接続で LAN1 に接続：IP は 192.168.5.1、有線接続で LAN2 に接続：IP は 192.168.200.1、無線接続：IP は 192.168.9.1

- Ubuntu 14.04 / Ubuntu 16.04 / Ubuntu 18.04、x86 および ARM（Nvidia TX2）

- Windows 7/10、Visual Studio 2015 Update3 / 2017 / 2019
  - C++11 コンパイラ

- 本 API インターフェースと Demo は、CR-V4 シリーズの V4 以上のコントローラバージョンに適用されます

## バージョンとリリース履歴

### 現在のバージョン v1.0.0.0

| バージョン |   変更日   |
| :--------: | :--------: |
|  v1.0.0.0  | 2023-11-20 |

# 2. 技術サポート

# 3. TCP-IP-CR-CPP-V4 制御プロトコル

TCP/IP に基づく通信は、低コスト・高信頼・実用性が高い・高性能といった特徴があります。多くの産業オートメーション案件で TCP/IP プロトコルによるロボット制御の需要が広く存在するため、Dobot ロボットは TCP/IP プロトコルを基盤として設計されており、外部機器との連携に使用できる豊富なインターフェースを提供しています。

ロボット状態の優先順位：

    1. エラー状態が最優先です。ロボットがエラーで、かつ未イネーブルの場合、状態はエラー状態を返します。

    2. 電源OFF状態が第二優先です。ロボットが未通電で、かつ未イネーブルの場合、状態は未通電状態を返します。

    3. 衝突状態が第三優先です。ロボットが衝突状態で、スクリプトが一時停止している場合、状態は衝突状態を返します。

    4. ブレーキ解除状態が第四優先です。ロボットがブレーキ解除で、未イネーブル状態の場合、状態はブレーキ解除状態を返します。

     それ以外の状態は実際の状況に応じて返されます。

ポートからのフィードバック情報：

    29999 サーバーポートは 1送信1受信 の方式で、設定および動作制御関連の指令を受け付けます。

    30004 サーバーポート（以下「リアルタイムフィードバックポート」）は 8ms ごとにロボット情報をフィードバックします。

    30005 サーバーポートは 200ms ごとにロボット情報をフィードバックします。

    30006 ポートはフィードバック周期を設定可能なロボット情報ポートです（デフォルトは 50ms）。

    30003 ポートは廃止。

プロトコルの詳細は **《越疆TCPIP制御プロトコル文書 6AXis-V4》** を参照してください。

# 4. TCP-IP-CR-CPP-V4 の入手

1. GitHub から Dobot TCP-IP-CR-CPP-V4 二次開発 API プログラムをダウンロードまたはクローンします。

   ```bash
   `git clone https://github.com/Dobot-Arm/TCP-IP-CR-CPP-V4 4.git
   ```

2. 対応する README.md ドキュメントを参照して使用します。

# 5. ファイル／クラスの説明と使い方

1. api ディレクトリには、CR に関連する機能をカプセル化した各種クラスが含まれており、C++ で実装されています。

2. api/rapidjson は [Tencent の json](https://github.com/Tencent/rapidjson) 解析ライブラリです。

3. api ディレクトリ内のクラス説明：

   | Parameter       | Default Value                                          |
   | --------------- | ------------------------------------------------------ |
   | BitConverter    | バイト列と基本型の変換をカプセル化                     |
   | DescartesPoint  | デカルト座標の構造体ラッパー                           |
   | JointPoint      | 関節座標の構造体ラッパー                               |
   | FeedbackData    | フィードバックデータ構造体のラッパー                   |
   | ErrorInfoBean   | エラー情報のカプセル化                                 |
   | ErrorInfoHelper | エラー情報ヘルパークラス                               |
   | DobotClient     | TCP 通信のインターフェースクラス（通信基盤を封装）     |
   | Dashboard       | DobotClient から派生。ロボット基本機能を実装           |
   | DobotMov        | DobotClient から派生。ロボット動作機能を実装           |
   | Feedback        | DobotClient から派生。ロボットフィードバック業務を実装 |
   |                 |                                                        |

4. `alarm_controller.json` は警告／アラーム設定ファイル、`alarm_servo.json` はサーボアラーム設定ファイルです。

**CDobotClient**

TCP 通信のインターフェースクラスです。ロボットへの TCP 接続、切断、IP/ポート取得などの機能を提供し、通信の基礎業務をカプセル化しています。

```c++
  class CDobotClient
  {
  public:
   }
```

**Dashboard**

DobotClient から派生し、設定関連の制御指令をロボットへ送信できます。ロボットの基本機能を具体的に実装しています。

```c++
class CDashboard : public CDobotClient
  {
  public:
   }
```

**Feedback**

DobotClient から派生し、ロボットのフィードバック業務を具体的に実装しています。ロボットの状態情報をリアルタイムにフィードバックできます。

```c++
  class CFeedbackData
  {
  public:
  };
```

**詳しい使い方はコード例 PythonExample.py と Demo 例を参照してください**

# 6. よくある質問

- TCP 接続に関する問題：

  29999 ポートは単一クライアント接続で、1 クライアントのみ接続可能です。

  30004 / 30005 / 30006 ポートは複数クライアントが同時接続可能です。

  29999 ポートはロボットモードの制限があります。開放前にロボットを TCP モードへ設定する必要があります。そうしないと指令送信後に応答せず、"Control Mode Is Not Tcp" が返ります。30004/30005/30006 のリアルタイムフィードバックポートにはモード制限はありません。

- ロボット状態を取得するには RobotMode() の戻り値を監視します。
  1. コントローラ起動中は初期化状態で、1 を返します。

  2. ロボット状態が 0 または 1 以外になったら初期化完了です。

  3. ロボット本体の電源OFF状態は 3 を返します。

  4. 初期化完了後で未イネーブルは未イネーブル状態で、4 を返します。

  5. イネーブル済みでアイドル状態は 5 を返し、動作指令を正常に受け付け可能です。

  6. movj（実行関連指令）、スクリプト実行およびその他のキュー指令は実行状態で、7 を返します。

  7. movJog（ジョグ）は単回動作状態で 8 を返します。未通電状態はありません。

     | モード | 説明                   | 備考                                  |
     | ------ | ---------------------- | ------------------------------------- |
     | 1      | ROBOT_MODE_INIT        | 初期化状態                            |
     | 2      | ROBOT_MODE_BRAKE_OPEN  | ブレーキ解除                          |
     | 3      | ROBOT_MODE_POWEROFF    | 本体電源OFF状態                       |
     | 4      | ROBOT_MODE_DISABLED    | 未イネーブル（ブレーキ未解除）        |
     | 5      | ROBOT_MODE_ENABLE      | イネーブル（アイドル）                |
     | 6      | ROBOT_MODE_BACKDRIVE   | ドラッグ                              |
     | 7      | ROBOT_MODE_RUNNING     | 実行状態（スクリプト／TCPキュー含む） |
     | 8      | ROBOT_MODE_SINGLE_MOVE | 単回動作状態（ジョグ）                |
     | 9      | ROBOT_MODE_ERROR       | エラー状態                            |
     | 10     | ROBOT_MODE_PAUSE       | 一時停止状態                          |
     | 11     | ROBOT_MODE_COLLISION   | 衝突状態                              |

- ロボット状態による指令応答
  - エラー状態で実行可能な指令：ClearError()、GetErrorID()、EmergeStop()、RobotMode()。それ以外の指令は拒否され、-2 を返します。

  - 緊急停止状態で実行可能な指令：ClearError()、GetErrorID()、EmergeStop()、RobotMode()。それ以外の指令は拒否され、-3 を返します。

  - 電源OFF状態で実行可能な指令：ClearError()、GetErrorID()、EmergeStop()、RobotMode()、PowerOn()。それ以外の指令は拒否され、-4 を返します。

  - TCP 指令は、ロボット状態に必須で影響する指令（EnableRobot()、PowerOn()）以外はすべて即時返却です。戻り値は送信成功を表すだけで、実行完了を表しません。

- 座標系に関する問題

  TCP/IP モードに入ると、ユーザー／ツール座標系はデフォルトで 0,0 に設定されます。TCP/IP モードを終了すると、上位PCで設定されたユーザー／ツール座標系のインデックス値へ自動的に復帰します。

  グローバル座標：User()、Tool() 指令で設定するのはグローバル座標系で、設定後はすべての指令に対して有効です。

  ローカル座標：動作指令の user/tool オプション引数は現在の動作指令にのみ有効で、指令実行後はグローバル座標系へ復帰します。

- アルゴリズムが許容するキュー深度は 64 です。連続して最大 64 件のキュー指令を同時処理できます。継続してキュー指令を送信して深度を超えると、ポートは切断されませんが、指令インターフェースは -1 を返し、指令は実行されません。

- キュー指令は即時返却です。成功の戻り値は送信成功を表すのみで、実行完了を表しません。実行完了の判定は CommandID と RobotMode を合わせて判断してください。

- サーボ稼働時間はイネーブル後の累積時間を表し、コントローラ稼働時間はコントローラ起動後（正常通電）の時間を表します。そのため、コントローラ稼働時間は常にサーボ稼働時間より大きくなります。

- 衝突状態はエラーではありません。GetErrorID() には衝突エラーは返りません。RobotMode() で衝突状態を照会でき、11 が返ります。ClearError() で衝突状態をクリアできます。

- 衝突発生後は通常通りのクリアエラー指令を送信し、衝突状態をクリアすれば再実行できます。再イネーブルは不要です。

- TCP/IP モードを切り替えると、速度／加速度／ユーザー・ツール座標系パラメータはデフォルト値に設定されます。EnableRobot() を呼んでデフォルトパラメータを設定する必要はありません。

- TCP キュー指令の戻り値は、指令パラメータと構文が規格に合っているかを示すだけで、指令が正常実行されたことを示しません。TCP キュー指令は送信後すぐに戻り、0 は送信が正常であることを示すだけで、実行成功を保証しません。

- TCP 指令のパラメータ型／数が誤っている場合は直ちに警報が発生し、0 埋め処理は行われず、指令はアルゴリズムへ渡されません。

- 緊急停止信号のトリガー後、ロボットはデフォルトで停止動作を行います。停止処理が 500ms を超えても停止しない場合は電源OFF動作を実行し、それ以外の場合は電源OFFしません。一般的に、ロボットは緊急停止後に電源OFFしません。

- デフォルトゲートウェイを設定すると数値は保存され、再起動後も値は変更されません。

- イネーブル指令はイネーブル動作のみを実行し、他のパラメータ設定は行いません。運動学パラメータや座標系パラメータはクリアされません。

- Pause()／Continue() 指令はスクリプト実行に有効で、動作指令（キュー関連）にも有効です。Pause() を呼ぶとロボットは一時停止状態になり、アルゴリズムキューは停止します。Continue() でキュー指令の実行を再開できます。MovJog（ジョグ）は単回実行状態のため、一時停止や再開はできません。

# 7. サンプル

- Dobot-Demo は TCP でロボット制御などの対話を実装しています。制御ポート、フィードバックポートに対して TCP 接続を行い、ロボットの動作指令の完了状態に応じて指令を送信し、ロボットの異常状態処理などの機能を含みます。

1. メインスレッド：制御ポート、動作ポート、フィードバックポートへそれぞれ接続します。ロボットのイネーブル、MovL 移動指令などを実行します。

![](/main.png)

2. フィードバック状態スレッド：ロボットの状態情報をリアルタイムでフィードバックします。

![](/feed.png)

3. ロボット動作スレッド：ロボットへ動作指令を送信します。

![](/move.png)

到達信号（動作完了）の判定：

キュー指令は即時返却です。成功の戻り値は送信成功を表すのみで、実行完了を表しません。実行完了の判定は以下を組み合わせて判断してください。

- 現在の CommandID が、送信した動作キュー指令の CommandID より大きい場合、送信したキュー指令は完了したことを示します。

- 現在の CommandID が送信した動作指令の CommandID と等しく、かつ RobotMode の戻り値が 5 の場合、送信したキュー指令は完了したことを示します。

4. 異常処理スレッド：ロボットの異常状態を判定し、処理を行います。

![](/exception.png)

- **Demo 実行手順（時系列）は以下の図の通りです：**

1. GitHub から越疆 Dobot TCP-IP-CR-CPP-V4 二次開発 API プログラムを取得します。

   ```bash
   `git clone https://github.com/Dobot-Arm/TCP-IP-CR-CPP-V4.git
   ```

2. LAN1 ポートでロボット本体に接続し、PC 側の IP アドレスを 192.168.5.X のセグメントに設定します。

   コントロール パネル >> ネットワーク >> Internet >> ネットワーク接続

   ![](/netConnect.png)

   接続しているイーサネットを選択 >> 右クリック >> プロパティ >> Internet プロトコル バージョン (TCP/IP-V4)

   IP アドレスを 192.168.5.X セグメントに変更します。

   ![](/updateIP.png)

3. 上位PC（DobotStudio Pro）に接続し、ロボットへ接続して、ロボットモードを TCP/IP モードに切り替えます。

   ![](./checkTcpMode.png)

4. プログラムの実行
   1. Dobot GitHub から越疆 Dobot TCP-IP-CR-CPP 二次開発 API プログラムを取得します。

      ```bash
      `git clone https://github.com/Dobot-Arm/TCP-IP-CR-CPP-V4.git`
      ```

      &ensp;&ensp;&ensp;&ensp;

   2. ディレクトリ TCP-IP-CR-CPP/CppDemo/ フォルダに入り、Demo プログラムをビルドします。

      ```bash
      cd  TCP-IP-CR-CPP-V4/CppDemo/
      bash compileDemo.sh
      ```

   3. Demo プログラムを実行します。

      ```bash
      bash runDemo.sh
      ```

**よくある問題：**

**問題1： ロボットが Tcp/IP モードであることを確認してください**

**問題2： Demo 内で、機種（CR）ごとにデカルト座標が異なる点を確認してください**

**サンプル実行前に、ロボットが安全な位置にあることを確認し、不要な衝突を防止してください**
